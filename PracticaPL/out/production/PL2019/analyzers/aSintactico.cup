package analyzers;
import java_cup.runtime.Symbol;
import java.io.*;

parser code{:
    public Converter c = new Converter();
    private String globalVariables = "";
    public void syntax_error(Symbol s){
        try{
            Token token = (Token)s.value;

            String lex = token.getLex();
            int line = token.getLine();
            int column = token.getColumn();

            System.out.println("Error sintactico capturado");
            System.out.println("\t\tLexema: " + lex);
            System.out.println("\t\tFila: " + line);
            System.out.println("\t\tColumna: " + column);
        }catch(NullPointerException e){System.out.println("Error sintáctico: falta el último símbolo");}
    }

    public void unrecovered_syntax_error(Symbol s){
         try{
             Token token = (Token)s.value;

             String lex = token.getLex();
             int line = token.getLine();
             int column = token.getColumn();

             System.out.println("Error sintactico capturado");
             System.out.println("\t\tLexema: " + lex);
             System.out.println("\t\tFila: " + line);
             System.out.println("\t\tColumna: " + column);
         }catch(NullPointerException e){System.out.println("Error sintáctico: falta el último símbolo");}
    }
:}

action code{:

:}


terminal cabecera, igual, identifier, constanteEntera, punto, puntoComa, dosPuntos, coma, parentesisAbierto, parentesisCerrado,
            fin, var, constanteReal, real, inicio, constant, entero, funcion, procedimiento, asignacion, suma, resta, producto, division,
            modulo, condMayor, condMenor, condMenorIgual, condMayorIgual, negacion, si, sino, entonces, mientras, hacer, repite, hasta,
            para, hastaArriba, hastaAbajo, paquete, condO, condY;

non terminal INITIAL, PRG, BLQ, DCLLIST, DCL, DEFCTE, CTELIST, SIMPVALUE, DEFVAR, DEFVARLIST, VARLIST, TBAS, DEFPROC, FORMAL_PARAMLIST,
             FORMAL_PARAM, DEFFUN, SENTLIST, SENT, ASIG, EXP, FACTOR, OP, OPARIT, PROC_CALL, SUBPARAMLIST, EXPLIST, EXPCOND, OPLOG, FACTORCOND,
             OPCOMP, INC;

precedence left condO, condY; 
precedence left suma, resta;
precedence left producto, division, modulo;

start with INITIAL;

INITIAL ::= PRG:txt {:c.bw.write((String)txt);:};

PRG ::= cabecera identifier puntoComa BLQ:blq punto {: Bloque b = (Bloque)blq; RESULT = b.getDcl() + "void main ( void )\n{\n" + b.getVariable() + b.getSent() + "}"; :}
            | paquete identifier puntoComa DCLLIST punto
            | error puntoComa;
BLQ ::= DCLLIST:dcl inicio SENTLIST:sent fin{:
                DCLList d = (DCLList)dcl;
                Bloque blq = new Bloque(d.getDcllists(), d.getVarslist(), (String)sent);
                RESULT = blq;
                :};
DCLLIST ::= DCLLIST:dcllist DCL:dcl {:
           DCLList d = (DCLList)dcllist;
           if(dcl instanceof Variable){
                Variable v = (Variable)dcl;
                d.setVarslist(d.getVarslist() + v.getVars());
           }else{
                d.setDcllists(d.getDcllists() + (String)dcl);
           }
           RESULT = d;
        :}
        |{: RESULT = new DCLList("",""); :};
DCL ::= DEFCTE:def {: RESULT = def; :}
        | DEFVAR:vars {: Variable v = new Variable((String)vars); RESULT = v;:}
        | DEFPROC:proc {: RESULT = proc; :}
        | DEFFUN:fun {: RESULT = fun; :};

DEFCTE ::= constant CTELIST:cte {: RESULT = cte; :}
        | error CTELIST;
CTELIST ::= identifier:id igual SIMPVALUE:value puntoComa {:
                Token token = (Token)id;
                RESULT = "#define " + token.getLex() + " = "  + value + ";\n";
                :}
            | CTELIST:list identifier:id igual SIMPVALUE:value puntoComa{:
                Token token = (Token)id;
                RESULT = list + "#define " + token.getLex() + " = "  + value + ";\n";
            :}
			| error puntoComa;
SIMPVALUE ::= constanteReal:r {:Token token = (Token)r; RESULT = token.getLex(); :}
            | constanteEntera:i {:Token token = (Token)i; RESULT = token.getLex(); :};

DEFVAR ::= var DEFVARLIST:list puntoComa{: RESULT = list + ";\n"; :};
DEFVARLIST ::= VARLIST:list dosPuntos TBAS:type {: RESULT = "\t" + (String)type + (String)list; :}
            | DEFVARLIST:deflist puntoComa VARLIST:list dosPuntos TBAS:type {: RESULT = deflist + ";\n" + "\t" + (String)type + (String)list; :}
            | error puntoComa;
VARLIST ::= identifier:id {: Token token = (Token)id; RESULT = token.getLex(); :}
            | identifier:id coma VARLIST:list {: Token token = (Token)id; RESULT = token.getLex() + ", " + list; :};

DEFPROC ::= procedimiento identifier:id FORMAL_PARAMLIST:params puntoComa BLQ:blq puntoComa {:
            Bloque b = (Bloque)blq;
            Token i = (Token)id;
            RESULT = "void " + i.getLex() + " " + params + "\n{\n" + b.getDcl() + b.getVariable() + b.getSent() + "}\n";
        :}
        | error puntoComa;
DEFFUN ::= funcion identifier:id FORMAL_PARAMLIST:params dosPuntos TBAS:type puntoComa BLQ:blq puntoComa{:
            Bloque b = (Bloque)blq;
            Token i = (Token)id;
            RESULT = type + " " + i.getLex() + " " + params + "\n{\n" + b.getDcl() + b.getVariable() + b.getSent() + "}\n";
        :};

FORMAL_PARAMLIST ::= parentesisAbierto FORMAL_PARAM:param parentesisCerrado {: RESULT = "(" + param + ")"; :}
        |{:RESULT = "";:};
FORMAL_PARAM ::= VARLIST:list dosPuntos TBAS:type {: RESULT = (String)type + (String)list; :}
        | VARLIST:list dosPuntos TBAS:type puntoComa FORMAL_PARAM:params {: RESULT = (String)type + (String)list + ", " + (String)params; :}
        | error parentesisCerrado;

TBAS ::= entero {: RESULT = "int "; :}
        | real{: RESULT = "float "; :};

SENTLIST ::= SENT:sent {:RESULT = sent;:}
        | SENTLIST:list SENT:sent {: RESULT = (String)list + (String)sent; :};

INC ::= hastaArriba | hastaAbajo;

SENT ::= ASIG:asig puntoComa {:RESULT ="\t" + asig + ";\n";:}
        | PROC_CALL puntoComa
        | si EXPCOND entonces BLQ sino BLQ
        | mientras EXPCOND hacer BLQ
        | repite BLQ hasta EXPCOND puntoComa
        | para identifier asignacion EXP INC EXP hacer BLQ
		| error puntoComa
		| error fin;

PROC_CALL ::= identifier SUBPARAMLIST;
SUBPARAMLIST ::= parentesisAbierto EXPLIST parentesisCerrado |;
EXPLIST ::= EXP | EXP coma EXPLIST | error parentesisCerrado;

ASIG ::= identifier:id asignacion EXP:exp {:Token token = (Token)id; RESULT = token.getLex() + " = " + exp; :};
EXP ::= EXP:exp1 OP:op EXP:exp2 {:RESULT = exp1 + " " + op + " " + exp2; :}
        | FACTOR:f {:RESULT = f; :};
OP ::= OPARIT:oparit {:RESULT = oparit; :};
OPARIT ::= suma {:RESULT = "+"; :}
        | resta {:RESULT = "-"; :}
        | producto {:RESULT = "*"; :}
        | division {:RESULT = "/"; :}
        | modulo{:RESULT = "%"; :};
FACTOR ::= SIMPVALUE:s {:RESULT = s; :}
        | parentesisAbierto EXP:e parentesisCerrado {: RESULT = "(" + e + ")"; :}
        | PROC_CALL:pc {: RESULT = pc; :};

EXPCOND ::= EXPCOND OPLOG EXPCOND | FACTORCOND;
OPLOG ::= condO | condY;
FACTORCOND ::= EXP OPCOMP EXP | parentesisAbierto EXP parentesisCerrado | negacion FACTORCOND | error parentesisCerrado;
OPCOMP ::= condMenor | condMayor | condMayorIgual | condMenorIgual | igual;

