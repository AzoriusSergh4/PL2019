package analyzers;
import java_cup.runtime.Symbol;
import java.io.*;

parser code{:
    public Converter c = new Converter();
    private String globalVariables = "";
    public void syntax_error(Symbol s){
        try{
            Token token = (Token)s.value;

            String lex = token.getLex();
            int line = token.getLine();
            int column = token.getColumn();

            System.out.println("Error sintactico capturado");
            System.out.println("\t\tLexema: " + lex);
            System.out.println("\t\tFila: " + line);
            System.out.println("\t\tColumna: " + column);
        }catch(NullPointerException e){System.out.println("Error sintáctico: falta el último símbolo");}
    }

    public void unrecovered_syntax_error(Symbol s){
         try{
             Token token = (Token)s.value;

             String lex = token.getLex();
             int line = token.getLine();
             int column = token.getColumn();

             System.out.println("Error sintactico capturado");
             System.out.println("\t\tLexema: " + lex);
             System.out.println("\t\tFila: " + line);
             System.out.println("\t\tColumna: " + column);
         }catch(NullPointerException e){System.out.println("Error sintáctico: falta el último símbolo");}
    }
:}

action code{:

:}


terminal cabecera, igual, identifier, constanteEntera, punto, puntoComa, dosPuntos, coma, parentesisAbierto, parentesisCerrado,
            fin, var, constanteReal, real, inicio, constant, entero, funcion, procedimiento, asignacion, suma, resta, producto, division,
            modulo, condMayor, condMenor, condMenorIgual, condMayorIgual, negacion, si, sino, entonces, mientras, hacer, repite, hasta,
            para, hastaArriba, hastaAbajo, paquete, condO, condY;

non terminal INITIAL, PRG, BLQ, DCLLIST, DCL, DEFCTE, CTELIST, SIMPVALUE, DEFVAR, DEFVARLIST, VARLIST, TBAS, DEFPROC, FORMAL_PARAMLIST,
             FORMAL_PARAM, DEFFUN, SENTLIST, SENT, ASIG, EXP, FACTOR, OP, OPARIT, PROC_CALL, SUBPARAMLIST, EXPLIST, EXPCOND, OPLOG, FACTORCOND,
             OPCOMP, INC;

precedence left condO, condY; 
precedence left suma, resta;
precedence left producto, division, modulo;

start with INITIAL;

INITIAL ::= PRG:txt {:c.bw.write((String)txt);:};

PRG ::= cabecera identifier puntoComa BLQ:blq punto {: Bloque b = (Bloque)blq; RESULT = b.getDcl() + "void main ( void )\n{\n" + b.getVariable() + b.getSent() + "\n}"; :}
            | paquete identifier puntoComa DCLLIST punto
            | error puntoComa;
BLQ ::= DCLLIST:dcl inicio SENTLIST:sent fin{:
                Bloque blq = new Bloque((String)dcl, globalVariables, (String)sent);
                RESULT = blq;
                :};
DCLLIST ::= DCLLIST:dcllist DCL:dcl {:RESULT = (String)dcllist + (String)dcl; :}
        |{: RESULT = ""; :};
DCL ::= DEFCTE:def {: RESULT = def; :}
        | DEFVAR:vars {: globalVariables = globalVariables + (String)vars; RESULT = "";:}
        | DEFPROC
        | DEFFUN;

DEFCTE ::= constant CTELIST:cte {: RESULT = cte; :}
        | error CTELIST;
CTELIST ::= identifier:id igual SIMPVALUE:value puntoComa {:
                Token token = (Token)id;
                RESULT = "#define " + token.getLex() + " = "  + value + ";\n";
                :}
            | CTELIST:list identifier:id igual SIMPVALUE:value puntoComa{:
                Token token = (Token)id;
                RESULT = list + "#define " + token.getLex() + " = "  + value + ";\n";
            :}
			| error puntoComa;
SIMPVALUE ::= constanteReal:r {:Token token = (Token)r; RESULT = token.getLex(); :}
            | constanteEntera:i {:Token token = (Token)i; RESULT = token.getLex(); :};

DEFVAR ::= var DEFVARLIST:list puntoComa{: RESULT = list + ";\n"; :};
DEFVARLIST ::= VARLIST:list dosPuntos TBAS:type {: RESULT = "\t" + (String)type + (String)list; :}
            | DEFVARLIST:deflist puntoComa VARLIST:list dosPuntos TBAS:type {: RESULT = deflist + ";\n" + "\t" + (String)type + (String)list; :}
            | error puntoComa;
VARLIST ::= identifier:id {: Token token = (Token)id; RESULT = token.getLex(); :}
            | identifier:id coma VARLIST:list {: Token token = (Token)id; RESULT = token.getLex() + ", " + list; :};

DEFPROC ::= procedimiento identifier FORMAL_PARAMLIST puntoComa BLQ puntoComa | error puntoComa;
DEFFUN ::= funcion identifier FORMAL_PARAMLIST dosPuntos TBAS puntoComa BLQ puntoComa;

FORMAL_PARAMLIST ::= parentesisAbierto FORMAL_PARAM parentesisCerrado |;
FORMAL_PARAM ::= VARLIST dosPuntos TBAS | VARLIST dosPuntos TBAS puntoComa FORMAL_PARAM | error parentesisCerrado;

TBAS ::= entero {: RESULT = "int "; :}
        | real{: RESULT = "float "; :};

SENTLIST ::= SENT:sent {:RESULT = sent;:}
        | SENTLIST SENT;

INC ::= hastaArriba | hastaAbajo;

SENT ::= ASIG:asig puntoComa {:RESULT ="\t" + asig + ";\n";:}
        | PROC_CALL puntoComa
        | si EXPCOND entonces BLQ sino BLQ
        | mientras EXPCOND hacer BLQ
        | repite BLQ hasta EXPCOND puntoComa
        | para identifier asignacion EXP INC EXP hacer BLQ
		| error puntoComa | error fin;

PROC_CALL ::= identifier SUBPARAMLIST;
SUBPARAMLIST ::= parentesisAbierto EXPLIST parentesisCerrado |;
EXPLIST ::= EXP | EXP coma EXPLIST | error parentesisCerrado;

ASIG ::= identifier:id asignacion EXP:exp {:Token token = (Token)id; RESULT = token.getLex() + " = " + exp; :};
EXP ::= EXP:exp1 OP:op EXP:exp2 {:RESULT = exp1 + " " + op + " " + exp2; :}
        | FACTOR:f {:RESULT = f; :};
OP ::= OPARIT:oparit {:RESULT = oparit; :};
OPARIT ::= suma {:RESULT = "+"; :}
        | resta {:RESULT = "-"; :}
        | producto {:RESULT = "*"; :}
        | division {:RESULT = "/"; :}
        | modulo{:RESULT = "%"; :};
FACTOR ::= SIMPVALUE:s {:RESULT = s; :}
        | parentesisAbierto EXP parentesisCerrado
        | PROC_CALL;

EXPCOND ::= EXPCOND OPLOG EXPCOND | FACTORCOND;
OPLOG ::= condO | condY;
FACTORCOND ::= EXP OPCOMP EXP | parentesisAbierto EXP parentesisCerrado | negacion FACTORCOND | error parentesisCerrado;
OPCOMP ::= condMenor | condMayor | condMayorIgual | condMenorIgual | igual;

